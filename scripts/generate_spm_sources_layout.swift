//#!/usr/bin/swift

//
//  generate_spm_sources_layout.swift
//
//  Created by Petro Rovenskyy on 09.03.2021.
//
//  Swift Package Manager [has some strict requirements](https://github.com/apple/swift-package-manager/blob/main/Documentation/Usage.md#creating-c-language-targets) to source files layout.
//  We can gain SPM support with minimal project structure changes by applying an autogenerated layout based on symbolic links technics.
//  SPM related files (public headers) located under `Texture/Source/include` folder.
//  SPM target which support IGListKit located under `Texture/AsyncDisplayKitIGListKit` folder which hold symbolic link to `Soure` folder.
//
//  You should **NEVER** modify it manually nor inlude to Xcode's project.
//   ### Generate SPM layout
//   1. From **project's root** run:
//     `swift scripts/generate_spm_sources_layout.swift`
//   2. Commit Changes
//   Repeate those steps each time you delete/add project's files. **Make sure** to have this CI step which will check that `generate_spm_sources_layout.swift` is not broken.

import Foundation

// MARK: Defines

struct SearchPath {
    enum SearchCfg: UInt8 {
        case currentDirOnly
        case includeSubirectories
    }
    let path: String
    let isDir: Bool
    let searchPattern: SearchCfg
    init(path: String,
         isDir: Bool,
         searchPattern: SearchCfg = .includeSubirectories) {
        self.path = path
        self.isDir = isDir
        self.searchPattern = searchPattern
    }
}

let exludeFilePaths: [SearchPath] = [
    .init(path: "Source/Classes/include", isDir: true),
    .init(path: "spm/Sources", isDir: true)
]

let publicHeadersLayout: [SearchPath] = [
    .init(path: "Source", isDir: true, searchPattern: .currentDirOnly),
    .init(path: "Source/Details", isDir: true),
    .init(path: "Source/Layout", isDir: true),
    .init(path: "Source/Base", isDir: true),
    .init(path: "Source/Debug", isDir: true),
    .init(path: "Source/TextKit/ASTextNodeTypes.h", isDir: false),
    .init(path: "Source/TextKit/ASTextKitComponents.h", isDir: false),
    .init(path: "Source/TextExperiment/Component", isDir: true, searchPattern: .currentDirOnly),
    .init(path: "Source/TextExperiment/String/ASTextAttribute.h", isDir: false),
]

// MARK: Helpers

func publicHeadersOnlyFromCurrent(directory path: String) -> [String] {
    let fm: FileManager = FileManager.default
    let items: [String] = try! fm.contentsOfDirectory(atPath: path)
        .filter({$0.hasSuffix(".h")})
        .compactMap({ (item) -> String in
            return path + "/" + item
        })
    return items
}

func publicHeadersIncludingSubdirectoriesFrom(directory path: String) -> [String] {
    let dirItems: FileManager.DirectoryEnumerator? = FileManager.default.enumerator(atPath: path)
    let sourceFilePaths: [String] = dirItems?.allObjects as! [String]
    var publicHeaders: [String] = []
    sourceFilePaths
        .filter({$0.hasSuffix(".h")})
        .forEach { (sourceItemPath) in
            let temp = path + "/" + sourceItemPath
            // Skip files if needed
            guard exludeFilePaths.allSatisfy({!temp.contains($0.path)}) else {
                return
            }
            // Validate that path make sence and file exists
            guard FileManager.default.fileExists(atPath: temp) else {
                fatalError("Could not find source file at path:\n \(path)")
            }
            publicHeaders.append(temp)
        }
    return publicHeaders
}

func privateHeadersAndImpl(sources: String, publicHeaders: [String]) -> [String] {
    var privateHeadersAndSources: [String] = []
    let dirItems: FileManager.DirectoryEnumerator? = FileManager.default.enumerator(atPath: sources)
    let sourceFilePaths: [String] = dirItems?.allObjects as! [String]
    sourceFilePaths.forEach { (path) in
        let fullPath = sources +  "/" + path
        var isDir: ObjCBool = false
        guard FileManager.default.fileExists(atPath: fullPath,
                                             isDirectory: &isDir) else {
            fatalError("Source file does not exist : \(fullPath)")
        }
        // filter folders
        if isDir.boolValue { return }
        // filter public headers
        if publicHeaders.contains(fullPath) {
            return
        }
        
        // collect sources
        if fullPath.hasSuffix(".h") ||
           fullPath.hasSuffix(".m") ||
           fullPath.hasSuffix(".mm") {
            // Collect path
            privateHeadersAndSources.append(fullPath)
        }
    }
    return privateHeadersAndSources
}

func createSymLinks(for sources: [String], atPath: String) {
    sources.forEach { (sourcePath) in
        let name = URL(string: sourcePath)!.lastPathComponent
        let symLinkPath = atPath + "/" + name
        do {
            try FileManager.default.createSymbolicLink(atPath: symLinkPath, withDestinationPath: sourcePath)
        } catch {
            fatalError(error.localizedDescription)
        }
    }
}

func cleanup(at: String) {
    let fm = FileManager.default
    do {
        let paths: [String] = try fm.contentsOfDirectory(atPath: at)
        for path in paths {
            try fm.removeItem(atPath: "\(at)/\(path)")
        }
    } catch {
        fatalError(error.localizedDescription)
    }
}

func generateSPM(publicHeadersPath: String, sourcesPath: String) {
    // 1. Delete all existing symlinks
    cleanup(at: sourcesPath)
    try! FileManager.default.createDirectory(atPath: publicHeadersPath,
                                             withIntermediateDirectories: true,
                                             attributes: nil)
    // 2. Find all public headers
    var publicHeaders: [String] = []
    publicHeadersLayout.forEach { (headerLayout) in
        let fPath = projectRoot + "/" + headerLayout.path
        // 2.1. Is it path to a file and not folder?
        // Just grab it.
        guard headerLayout.isDir else {
            assert(FileManager.default.fileExists(atPath: fPath),
                   "Could not find source file at path:\n \(fPath)")
            publicHeaders.append(fPath)
            return
        }
        // 2.2. It's a folder path, search.
        switch headerLayout.searchPattern {
        case .currentDirOnly:
            let currentFolder = publicHeadersOnlyFromCurrent(directory: fPath)
            publicHeaders.append(contentsOf: currentFolder)
        case .includeSubirectories:
            let subfolders = publicHeadersIncludingSubdirectoriesFrom(directory: fPath)
            publicHeaders.append(contentsOf: subfolders)
        }
    }
    
    // 3. Create symbolic links for public headers
    let relativeHeadersPath = publicHeaders.map { (headerPath) -> String in
        let relativePath  = headerPath.replacingOccurrences(of: projectRoot,
                                                            with: "../../../..")
        return relativePath
    }
    createSymLinks(for: relativeHeadersPath, atPath: publicHeadersPath)
    
    // 4. Find private headers and impl files.
    let privateSources: [String] = privateHeadersAndImpl(sources: sourceFolder,
                                                         publicHeaders: publicHeaders)
    let relativeSourcesPath = privateSources.map { (sourcePath) -> String in
        let relativePath  = sourcePath.replacingOccurrences(of: projectRoot,
                                                            with: "../../..")
        return relativePath
    }
    
    // 5. Create symbolic links for source files
    createSymLinks(for: relativeSourcesPath, atPath: sourcesPath)
}

// MARK: Script start

let projectRoot: String = FileManager.default.currentDirectoryPath
let sourceFolder: String = projectRoot + "/Source"

// MARK: Generate AsyncDisplayKit SPM layout
let asdkPublicHeadersPath = projectRoot + "/spm/Sources/AsyncDisplayKit/include"
let asdkSourcesPath = projectRoot + "/spm/Sources/AsyncDisplayKit"

generateSPM(publicHeadersPath: asdkPublicHeadersPath,
            sourcesPath: asdkSourcesPath)

// MARK: Script end
